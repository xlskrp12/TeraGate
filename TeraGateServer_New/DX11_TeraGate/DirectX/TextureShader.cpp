#include "TextureShader.h"
TextureShader::TextureShader()
{
    _vs           = NULL;
    _ps           = NULL;
    _inputLayout  = NULL;
    _samplerState = NULL;
    _vsCBuffer    = NULL;
}
TextureShader::TextureShader(const TextureShader& textureShader)
{

}
TextureShader::~TextureShader()
{
}
void TextureShader::init(ID3D11Device* device, HWND hwnd)
{
    initShader(device, hwnd, L"Shader/TextureVS.hlsl", L"Shader/TexturePS.hlsl");
#ifdef _DEBUG
    printf("TextureShader::init();\n");
#endif
}
void TextureShader::release()
{
    releaseShader();
}
void TextureShader::render(
    ID3D11DeviceContext      *deviceContext, 
    int                      indexCount,
    D3DXMATRIX               mtxWorld,
    D3DXMATRIX               mtxView,
    D3DXMATRIX               mtxProjection,
    ID3D11ShaderResourceView *texture)
{
    setShaderParameter(deviceContext, mtxWorld, mtxView, mtxProjection, texture);
    renderShader(deviceContext, indexCount);
}
void TextureShader::initShader(
    ID3D11Device* device,
    HWND hwnd,
    WCHAR* vsFileName,
    WCHAR* psFileName)
{
    HRESULT                  result;
    ID3D10Blob               *errorMessage = NULL;
    ID3D10Blob               *vs           = NULL;
    ID3D10Blob               *ps           = NULL;
    D3D11_INPUT_ELEMENT_DESC inputLayoutDesc[2];
    unsigned int             inputNumber;
    D3D11_SAMPLER_DESC       samplerDesc;
    D3D11_BUFFER_DESC        vsCBufferDesc;
    //▼정점셰이더 생성
    result = D3DX11CompileFromFile(vsFileName, NULL, NULL, "TextureVertexShader", "vs_5_0", D3D10_SHADER_ENABLE_STRICTNESS, 0, NULL, &vs, &errorMessage,NULL);
    if (FAILED(result))
    {
        if (errorMessage)
        {
            outputShaderErrorMessage(errorMessage, hwnd, vsFileName);
            MessageBox(NULL, L"D3DX11CompileFromFile()", L"Error", NULL);
        }
        else
        {
            // 에러메시지가 없다면 파일을 찾지 못한 것.
            WCHAR wstr[100];
            wsprintf(wstr, L"D3DX11ComfileFromFile()\n지정한 파일을 찾지 못했습니다.\n%s\n", vsFileName);
            MessageBox(NULL, wstr, L"Error", NULL);
        }
    }
    //▼ ID3D11Device::CreateVertexShader(
    // [in]            const void*          pHsaderByteCode, // 컴파일된 셰이더를 가리키는 포인터
    // [in]            SIZE_T               VytecodeLength,  // 컴파일된 버텍스 셰이더 크기
    // [in, optional ] ID3D11ClassLinkage*  pClassLinkage,   // 연결 인터페이스(?)를 위한 포인터
    // [out, optional] ID3D11VertexShader** ppVertexShader   // ID3D11VertexShader 인터페이스를 가리킬 포인터.
    // );
    result = device->CreateVertexShader(vs->GetBufferPointer(), vs->GetBufferSize(), NULL, &_vs);
    if (FAILED(result))
        MessageBox(NULL, L"ID3D11Device::CreateVertexShader()", L"Error", NULL);

    //▼픽셀셰이더 생성
    result = D3DX11CompileFromFile(psFileName, NULL, NULL, "TexturePixelShader", "ps_5_0", D3D10_SHADER_ENABLE_STRICTNESS, 0, NULL, &ps, &errorMessage, NULL);
    if (FAILED(result))
    {
        if (errorMessage)
        {
            outputShaderErrorMessage(errorMessage, hwnd, psFileName);
        }
        else
        {
            // 에러메시지가 없다면 파일을 찾지 못한 것.
            WCHAR wstr[100];
            wsprintf(wstr, L"D3DX11ComfileFromFile()\n지정한 파일을 찾지 못했습니다.\n%s\n", psFileName);
            MessageBox(NULL, wstr, L"Error", NULL);
        }
    }
    result = device->CreatePixelShader(ps->GetBufferPointer(), ps->GetBufferSize(), NULL, &_ps);
    if (FAILED(result))
        MessageBox(NULL, L"ID3D11Device::CreatePixelShader()", L"Error", NULL);

    //▼인풋 디스크립션 생성
    inputLayoutDesc[0].SemanticName         = "POSITION";
    inputLayoutDesc[0].SemanticIndex        = 0;
    inputLayoutDesc[0].Format               = DXGI_FORMAT_R32G32B32_FLOAT; 
    inputLayoutDesc[0].InputSlot            = 0;
    inputLayoutDesc[0].AlignedByteOffset    = 0;
    inputLayoutDesc[0].InputSlotClass       = D3D11_INPUT_PER_VERTEX_DATA;
    inputLayoutDesc[0].InstanceDataStepRate = 0;
    inputLayoutDesc[1].SemanticName         = "TEXCOORD";//"COLOR", "TEXCOORD"
    inputLayoutDesc[1].SemanticIndex        = 0 ;
    inputLayoutDesc[1].Format               = DXGI_FORMAT_R32G32_FLOAT;// DXGI_FORMAT_R32G32B32_FLOAT, DXGI_FORMAT_R32G32_FLOAT
    inputLayoutDesc[1].InputSlot            = 0;
    inputLayoutDesc[1].AlignedByteOffset    = D3D11_APPEND_ALIGNED_ELEMENT; // 버퍼에 데이터가 어떻게 배열되는지를 알려줘야하는데, 자동으로 알아내라는 뜻
    inputLayoutDesc[1].InputSlotClass       = D3D11_INPUT_PER_VERTEX_DATA;
    inputLayoutDesc[1].InstanceDataStepRate = 0;
    inputNumber = sizeof(inputLayoutDesc) / sizeof(inputLayoutDesc[0]);
    result = device->CreateInputLayout(inputLayoutDesc, inputNumber, vs->GetBufferPointer(), vs->GetBufferSize(), &_inputLayout);
    if (FAILED(result))
        MessageBox(NULL, L"ID3D11Device::CreateInputLayout()", L"Error", NULL);

    //▼인풋 디스크립션 생성 후 정점&픽셀 셰이더 버퍼는 사용하지 않으므로 해제
    vs->Release();
    vs = NULL;
    ps->Release();
    ps  = NULL;

    //▼vs상수버퍼와 같은 자료형 생성
    vsCBufferDesc.Usage                = D3D11_USAGE_DYNAMIC;
    vsCBufferDesc.ByteWidth            = sizeof(VSCBuffer);
    vsCBufferDesc.BindFlags            = D3D11_BIND_CONSTANT_BUFFER;// 상수버퍼를 이 버퍼로 한다고 설정.
    vsCBufferDesc.CPUAccessFlags       = D3D11_CPU_ACCESS_WRITE;    // 상수버퍼 용도에 맞는 값
    vsCBufferDesc.MiscFlags            = 0;
    vsCBufferDesc.StructureByteStride  = 0;
    result = device->CreateBuffer(&vsCBufferDesc, NULL, &_vsCBuffer);
    if (FAILED(result))
        MessageBox(NULL, L"ID3D11Device::CreateBuffer()", L"Error", NULL);

    //▼샘플러 스테이트 생성
    samplerDesc.Filter         = D3D11_FILTER_MIN_MAG_MIP_LINEAR;// 샘플러가 축소확대+밉레벨 샘플링시 선형보간(linear interpolation)사용 // 처리량은 좀 무겁지만 퀄리티가 좋다.
    samplerDesc.AddressU       = D3D11_TEXTURE_ADDRESS_WRAP;
    samplerDesc.AddressV       = D3D11_TEXTURE_ADDRESS_WRAP;
    samplerDesc.AddressW       = D3D11_TEXTURE_ADDRESS_WRAP;
    samplerDesc.MipLODBias     = 0.0f;
    samplerDesc.MaxAnisotropy  = 1;
    samplerDesc.ComparisonFunc = D3D11_COMPARISON_ALWAYS;
    samplerDesc.BorderColor[0] = 0;
    samplerDesc.BorderColor[1] = 0;
    samplerDesc.BorderColor[2] = 0;
    samplerDesc.BorderColor[3] = 0;
    samplerDesc.MinLOD         = 0;
    samplerDesc.MaxLOD         = D3D11_FLOAT32_MAX;
    result = device->CreateSamplerState(&samplerDesc, &_samplerState);
    if (FAILED(result))
        MessageBox(NULL, L"ID3D11Device::CreateSamplerState()", L"Error", NULL);
}
void TextureShader::releaseShader()
{
    if (_samplerState)
    {
        _samplerState->Release();
        _samplerState = NULL;
    }
    if (_vsCBuffer)
    {
        _vsCBuffer->Release();
        _vsCBuffer = NULL;
    }
    if (_inputLayout)
    {
        _inputLayout->Release();
        _inputLayout = NULL;
    }
    if (_ps)
    {
        _ps->Release();
        _ps = NULL;
    }
    if (_vs)
    {
        _vs->Release();
        _vs = NULL;
    }
}
void TextureShader::outputShaderErrorMessage(ID3D10Blob *errorMessage, HWND hwnd,  WCHAR *shaderFileName)
{
    using std::ofstream;
    char*         compileError;
    unsigned long bufferSize;
    ofstream      file;

    compileError = (char*)(errorMessage->GetBufferPointer());
    bufferSize   = errorMessage->GetBufferSize();
    file.open("shader-error.txt");
    for (int i = 0; i < bufferSize; i++)
    {
        file << compileError[i];
    }
    file.close();
    errorMessage->Release();
    errorMessage = NULL;

    WCHAR wstr[100];
    wsprintf(wstr, L"%s\n셰이더 파일을 컴파일하는데 문제가 생겼습니다.\n", shaderFileName);
    MessageBox(hwnd, wstr, L"Error", NULL);
}
void TextureShader::setShaderParameter(ID3D11DeviceContext *deviceContext, D3DXMATRIX mtxWorld, D3DXMATRIX mtxView, D3DXMATRIX mtxProjection, ID3D11ShaderResourceView *texture)
{
    HRESULT                  result;
    D3D11_MAPPED_SUBRESOURCE mappedResource;
    VSCBuffer*               vsCBuffer;
    unsigned int             bufferNumber;

    // transpose (전치행렬)
    // 행렬을 transpose해 셰이더에서 사용할 수 있게 만든다.
    D3DXMatrixTranspose(&mtxWorld, &mtxWorld);
    D3DXMatrixTranspose(&mtxView, &mtxView);
    D3DXMatrixTranspose(&mtxProjection, &mtxProjection);

    // 상수버퍼의 내용을 사용할 수 있도록 잠금
    result = deviceContext->Map(_vsCBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
    if (FAILED(result))
        MessageBox(NULL, L"ID3D11DeviceContext::Map()", L"Error", NULL);

    // 상수버퍼의 데이터에 대한 포인터를 가져온다.
    vsCBuffer = (VSCBuffer*)mappedResource.pData;
    vsCBuffer->mtxWorld      = mtxWorld;
    vsCBuffer->mtxView       = mtxView;
    vsCBuffer->mtxProjection = mtxProjection;

    // 상수버퍼의 잠금을 푼다.
    deviceContext->Unmap(_vsCBuffer, 0);

    // 버텍스 셰이더에 있는 상수버퍼의 포지션을 0으로
    bufferNumber = 0;

    // 버텍스셰이더 상수버퍼 set
    deviceContext->VSSetConstantBuffers(bufferNumber, 1, &_vsCBuffer);

    // 픽셀셰이더에 텍스쳐 리소스 set
    deviceContext->PSSetShaderResources(0, 1, &texture);
}
void TextureShader::renderShader(ID3D11DeviceContext* deviceContext, int indexCount)
{
    deviceContext->IASetInputLayout(_inputLayout);     // 입력 레이아웃         set
    deviceContext->VSSetShader(_vs, NULL, 0);          // 정점셰이더            set
    deviceContext->PSSetShader(_ps, NULL, 0);          // 픽셀셰이더            set
    deviceContext->PSSetSamplers(0, 1, &_samplerState);// 픽셀셰이더 샘플러 상태 set 
    deviceContext->DrawIndexed(indexCount, 0, 0);      // 그리기
}